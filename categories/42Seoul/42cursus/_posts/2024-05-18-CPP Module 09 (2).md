---
layout: post
title: CPP Module 09 (2)
excerpt: "42cursus - CPP Module 09 / 2024-05-17 통과"
tags: [42Seoul, 42서울, born2code, 42cursus, CPP Module 09, CPP Module, C++, CPP]
date: 2024-05-18
use_math: true
---

# 이전 글
<a href="/categories/42Seoul/42cursus/CPP-Module-09-(1)">CPP Module 09 - (1)</a>

## Exercise 02: PmergeMe

아예 서브젝트에 Ford-johnson 알고리즘을 사용하라고 명시가 되어 있다. 어떻게 적어야할 지 막막한데 일단은 끄적여보겠다.

**재귀를 쓰지 않는 코드는 포드 존슨 알고리즘이 아니다..!!**  

Art of Computer Programming(이하 TAOCP) - Volume 3의 5.3.1, WIKIPEDIA의 <a href="https://en.wikipedia.org/wiki/Merge-insertion_sort">Merge-insertion sort</a>를 참고하자.

### 비교 정렬의 하한

먼저 비교 정렬의 하한을 알아보자. 결론 먼저 보면, 비교 정렬의 하한은 $nlog{n}$ 이다. 즉 어떠한 비교 정렬도 $nlog{n}$ 이상의 효율이 나올 수는 없다. 왜 그럴까?

예를 들어, x, y, z의 세 원소를 정렬한다고 해보자.  

<center><img src="/assets/CPP Module 09/IMG_0016.jpg" width="40%"> </center>
이 떄 결정 트리의 리프(잎, 가장 끝의 노드) 개수는 $3! = 6$ 이다. 즉, 가능한 리프의 최소 개수는 $n!$ 을 따른다.  
또한 최대 개수는 결정 트리의 높이(위 예시에서, 높이는 3이다.)를 따른다. 즉, $h$ 를 결정 트리의 높이라 할 때 최대 개수는 $2^h$ 이다.  
이에 대해 TAOCP에서는 다음과 같이 말하고 있다.  

*<center>it follow that there are exactly $n!$ external nodes in a comparison tree that sorts n elements with no redundant comparisons.</center>*  
*<center>.</center>*
*<center>.</center>*
*<center>.</center>*  
*<center>If all the internal nodes of a comparison tree are at levels < k, it is obvious that there can be at most $2^k$ external nodes in the tree.</center>*  
*<center>(TACOP - 5.3.1, p.182)</center>*
  
즉, 리프의 개수를 $L$ 이라 할 때, $L$ 은 다음을 따른다.
<center>$n! \le L \le 2^h$</center>
이제 양변에 로그를 취하면,
<center>$h \ge log{n!}$</center>
이고, 이는 <a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%84%B8%EB%A7%81_%EA%B7%BC%EC%82%AC">스털링 근사</a>에 의하여 다음을 따른다.
<center>$ log{n!} \thickapprox nlog{n} - \frac{n}{ln{2}} + \frac{1}{2}log{n} + O(1)$</center>

결론적으로 비교 정렬의 하한은 $nlog{n}$ 이라는 것이 증명된다.

### ford-johnson의 로직

TACOP에서는 Binary insertion과 straight two-way merging을 언급하며 두 방법 모두  점근적으로 $nlog{n}$ 에 도달한다고 얘기한다. 다음의 표를 살펴보자.  
B(n)은 Binary insertion의 비교 횟수, L(n)은 two-way list merging의 비교 횟수이다.
<center><img src="/assets/CPP Module 09/IMG_0017.jpg" width="65%"></center>
<center>(TACOP - 5.3.1, p.183)</center>
위 표에서는 모든 $n$ 에 대하여 $B(n) \le L(n)$ 따르는 것으로 보인다. TACOP에서는 여기서 한 가지 의문을 제시한다.  
$S(4)=5$ 지만, $S(5)$ 는 7이거나 8이다. **다섯 개의 요소를 7번의 비교만을 통해 정렬할 수 있을까?** 여기서 시작된 것이 포드 존슨 알고리즘이다.  

다음은 구체적인 방법에 대해서 알아보자. 예를 들어, [11, 7, 5, 3, 20, 22] 의 수열을 정렬 하려 한다.
<center><img src="/assets/CPP Module 09/IMG_FB8E4911551A-1.jpeg" width="50%"></center>

먼저 위와 같이 2개씩 쌍을 지어, 각 쌍을 정렬한다. (비교 횟수: 3)  
이후, 큰 쌍들을 기준으로 정렬한다. 그러면 다음과 같이 chain구조가 만들어진다.
<center><img src="/assets/CPP Module 09/IMG_564209E1D570-1.jpeg" width="50%"></center>  
위의 큰 숫자들의 수열($a_k$)을 main-chain이라고 부르자. 각각의 요소는 항상 main-chain이 클 것이다($a_k > b_k$). 이제 작은 숫자들($b_k$)을 각각 main-chain에 이분 탐색을 통해 삽입할 것이다. 단, 삽입하는 $b_k$의 순서는 1, 3, 2, 5, 4, 11, 10, 9, 8 ... (<a href="https://en.wikipedia.org/wiki/Jacobsthal_number">Jacobsthal Number</a>) 의 k를 따른다. 왜 그런지는 나중에 설명하겠다.  
  

<center><img src="/assets/CPP Module 09/IMG_96FB6C774A81-1.jpeg" width="60%"></center>
  
i) $b_1$ 삽입: $b_1$은 $a_1$보다 작으므로 무조건 main-chain의 맨 앞에(main-chain은 정렬되어있기 때문에) 삽입된다. (비교 횟수: 3 + 0)  

ii) $b_3$ 삽입: $b_3$은 $a_3$보다 작으므로 이분 탐색의 범위는 $b_1$ ~ $a_2$ 이다. 이분 탐색의 비교 횟수는 2번이다. (비교 횟수: 3 + 0 + 2)

iii) $b_2$ 삽입: $b_2$는 $a_2$보다 작으므로, 이분 탐색의 범위는 $b_1$ ~ $a_1$ 이다. 이분 탐색의 비교 횟수는 2번이다. (비교 횟수: 3 + 0 + 2 + 2)  
  
**결과적으로 7번의 비교 횟수를 통해 정렬되었다.**  

그렇다면 만약 $b_1$ 다음 $b_2$를 먼저 삽입하면 어떻게 될까? 먼저 이분 탐색의 최대 비교 횟수는 다음과 같다.
<center><img src="/assets/CPP Module 09/IMG_1291A1FB2AF6-1.jpeg" width="40%"></center>  

요소의 개수가 $2^k$의 따라 최대 비교 횟수가 바뀌는 것을 알 수 있다. $B(n)$을 이분 탐색의 최대 횟수라고 해보자.
<center><img src="/assets/CPP Module 09/IMG_E99854ACBD57-1.jpeg" width="60%"></center>

i) $b_2$ 삽입: $b_2$는 $a_2$보다 작으므로, 이분 탐색의 범위는 $b_1$ ~ $a_1$이며 $B(2) = 2$이다. (비교 횟수: 3 + 0 + 2)  

ii) $b_3$ 삽입: $b_3$는 $a_3$보다 작으므로, 이분 탐색의 횟수는 **$b_2$가 이미 삽입되어 있으므로 $B(4) = 3$**이다. (비교 횟수: 3 + 0 + 2 + 3)  

**이전과 다르게 비교 횟수가 8번이 나왔다**

여기서 우리는, $b_k$를 선택하는 기준이 이분 탐색의 범위가 바뀌지 않는 지점부터 거꾸로 내려온다는 것을 알 수 있다.
<center><img src="/assets/CPP Module 09/IMG_892CE2617354-1.jpeg" width="50%"></center>  

자 그럼, 일반화를 해보자.
